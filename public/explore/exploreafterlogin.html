<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonprofit Listings</title>
    <!-- Vue.js -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- Bootstrap for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="explore.css">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="../config.js"></script> <!-- Firebase config file -->
    <script>
        const googleMapsScript = document.createElement('script');
        googleMapsScript.src = `https://maps.googleapis.com/maps/api/js?key=${window.APP_CONFIG.GOOGLE_MAPS_API_KEY}`;
        document.head.appendChild(googleMapsScript);
    </script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script></script>
</head>

<script>
    // Setting the userId global variable through sessionStorage.
    let userId;
    window.onload = function(){
        userId = sessionStorage.getItem('userId');
        console.log("The user ID is : ", userId);
    }
</script>

<body>
    <div id="body">
        <div id="app">
    <nav class="navbar navbar-expand-lg">
        <div class="container-fluid">
            <!-- Navbar Brand -->
            <a class="navbar-brand" href="#">
                <img src="../loginBranch/images/Volunteer.png" alt="logo" />
            </a>

            <!-- Toggler for mobile view -->
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Navbar Links-->
            <div class="collapse navbar-collapse justify-content-center" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../loginBranch/homepageafterlogin.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="active" href="#">Explore</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../calendar/calendar.html">Calendar</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../donation/donateaftlogin.html">Donate</a>
                    </li>

                </ul>
            </div>

            <!-- Sign In Button on the far right -->
            <div class="d-flex">
                <button id="signin" class="btn" type="button" onclick="window.location.href='../loginBranch/profile.html'">My Profile</button>
            </div>
        </div>
    </nav>

    <div class="jumbotron">
        <div id="jumbotron-carousel" class="carousel slide" data-bs-ride="carousel">
            <div class="carousel-inner">
                <div class="carousel-item active">
                    <img src="help6.jpg" class="d-block w-100" alt="Image 1">
                </div>
                <div class="carousel-item">
                    <img src="help5.jpg" class="d-block w-100" alt="Image 2">
                </div>
                <div class="carousel-item">
                    <img src="vol1.jpg" class="d-block w-100" alt="Image 3">
                </div>
                <div class="carousel-item">
                    <img src="help8.jpg" class="d-block w-100" alt="Image 4">
                </div>
            </div>
            <button class="carousel-control-prev" type="button" data-bs-target="#jumbotron-carousel"
                data-bs-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Previous</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#jumbotron-carousel"
                data-bs-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Next</span>
            </button>
        </div>
        <div class="jumbotron-content">
            <h1>EXPLORE</h1>
            <p>The opportunities designed to fit you</p>
            <a href="../Posting/posting.html" class="button">Create a Post</a>
            <a v-if="isAdmin" href="../admin/admin.html" class="button mx-2">Approve Posts!</a>
        </div>
    </div>

            
            <!-- Top Matches Section -->
            <div class="container mt-0" v-if="showMatchBar">
                <div v-if="isLoading" class="text-center my-5">
                    <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Calculating your top matches...</p>
                </div>
                <div v-else class="topmatch-container">
                    <h3 class="header">Your Top Matches</h3>
                    <div class="scrollable-row-wrapper d-flex flex-nowrap overflow-auto">
                        <div class="card topmatch" v-for="(card, index) in topRecommendedCards" :key="index"
                            @click="openPreview(card)">
                            <img :src="card.imageUrl" class="card-img-top" alt="Card image">

                            <!-- Progress Bar for Match Score -->
                            <div class="progress" style="height: 20px; margin-top: -4px; z-index:1 ;">
                                <div style="background-color: rgb(71, 166, 71);" class="progress-bar" role="progressbar"
                                    :style="{ width: card.matchScore + '%' }" :aria-valuenow="card.matchScore"
                                    aria-valuemin="0" aria-valuemax="100">
                                    {{ card.matchScore }}% Match
                                </div>
                            </div>

                            <div class="card-body">
                                <h5 class="card-title info-text">{{ card.title }}</h5>
                                <p class="card-text description-text">{{ card.description }}</p>
                                <p class="card-text info-text"><strong>Location:</strong> {{ card.location }}</p>
                                <p class="card-text  info-text"><strong>Skills:</strong> {{ Array.isArray(card.skills) ?
                                    card.skills.join(', ') : card.skills || "No skills listed" }}</p>
                                <p v-if="card.isRecurring" class="card-text"><strong>Weekly: </strong> {{
                                    Array.isArray(card.recurringDays) ? card.recurringDays.join(', ') :
                                    selectedCard.recurringDays || "No days listed" }}</p>
                                <p v-else class="card-text"><strong>Date: </strong>{{card.date}}</p>
                            </div>
                            <div class="card-footer text-center">
                                <a :href="card.mainurl" target="_blank" class="btn btn-primary">View Website</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>




        <!-- Add this right after your <div id="app"> -->
            <div class="topmatch-preview" v-if="showPreview" @click.self="closePreview">
                <div class="preview">
                    <div class="close-button" @click="closePreview">
                        <i class="fas fa-times"></i>
                    </div>
            
                    <div v-if="selectedCard" class="preview-content">
                        <div class="preview-header">
                            <img :src="selectedCard.imageUrl" class="preview-logo" alt="Organization logo">
                            <h5 class="card-title">{{ selectedCard.title }}</h5>
                        </div>
            
                        <div class="card-body">
                            <p class="card-text">{{ selectedCard.description }}</p>
                            <p class="card-text"><strong>Skills Needed:</strong> {{ Array.isArray(selectedCard.skills) ?
                                selectedCard.skills.join(', ') : selectedCard.skills || "No skills listed" }}</p>
                            <p v-if="selectedCard.isRecurring" class="card-text"><strong>Weekly Commitment:</strong> {{
                                Array.isArray(selectedCard.recurringDays) ? selectedCard.recurringDays.join(', ') :
                                selectedCard.recurringDays || "No days listed" }}</p>
                            <p v-if="selectedCard.isRecurring" class="card-text"><strong>Event Commitment Period:
                                </strong>{{selectedCard.recurringStartDate}} till {{ selectedCard.recurringEndDate}}</p>
                            <p v-else class="card-text"><strong>Date: </strong>{{selectedCard.date}}</p>
                            <p class="card-text"><strong>Time:</strong> {{ selectedCard.startTime }} - {{
                                selectedCard.endTime}}</p>
                            <p class="card-text"><strong>Postal Code:</strong> {{ selectedCard.location }}</p>
                            <div id="previewMap" style="height: 300px; width: 100%; margin-top: 15px; background: #f0f0f0; border: 1px solid #ccc; position: relative; min-height: 300px;">
                                <!-- Loading indicator -->
                                <div class="map-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                                    <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading map...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
            
                        <div class="card-footer text-center">
                            <p class="card-text"><strong>Email: </strong>{{ selectedCard.email }}</p>
                            <a :href="selectedCard.mainurl" target="_blank" class="btn btn-primary mx-5">View Website</a>
                            <button v-if="selectedCard.isRecurring" class="btn btn-primary" 
                                @click="send_to_calendar_recurring(selectedCard.recurringDays, selectedCard.startTime, 
                                    selectedCard.endTime, true, selectedCard.title, selectedCard.recurringStartDate, 
                                    selectedCard.recurringEndDate)">Add to Calendar</button>
                            <button v-else class="btn btn-primary" 
                                @click="send_to_calendar_nonrecurring(selectedCard.daysOfWeek, selectedCard.startTime, 
                                    selectedCard.endTime, false, selectedCard.title, selectedCard.date)">Add to Calendar</button>
                        </div>
                    </div>
            
                    <!-- Toast Notification -->
                    <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
                        <div id="calendarToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                            <div class="toast-header">
                                <strong class="me-auto">Calendar Update</strong>
                                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                            </div>
                            <div class="toast-body" id="toastMessage">
                            </div>
                        </div>
                    </div>
                </div>
            </div>




            <div class="container my-4">
                <div class="text-center my-4">
                    <h2 class="header">General Listings</h2>
                </div>

                <div class="filters-container">
                    <!-- Skills Filter Section -->
                    <div class="skills-filter-section">
                        <div class="filter-header">
                            <h4>Filter by Skills</h4>
                            <button type="button" class="clear-filters-btn" v-if="hasSelectedFilters"
                                @click.stop="clearAllFilters">
                                Clear All
                            </button>
                        </div>
                        <div class="filter-chips">
                            <button type="button" v-for="skill in availableSkills" :key="skill"
                                @click.stop="toggleFilter(skill)"
                                :class="['filter-chip', {'active': selectedFilters.includes(skill)}]">
                                <span class="filter-text">{{ skill }}</span>
                                <span class="filter-icon" v-if="selectedFilters.includes(skill)">✓</span>
                            </button>
                        </div>
                    </div>

                    <!-- Categories Filter Section -->
                    <div class="skills-filter-section">
                        <div class="filter-header">
                            <h4>Filter by Categories</h4>
                        </div>
                        <div class="filter-chips">
                            <button type="button" v-for="category in availableCategories" :key="category"
                                @click.stop="toggleFilter(category)"
                                :class="['filter-chip', {'active': selectedFilters.includes(category)}]">
                                <span class="filter-text">{{ category }}</span>
                                <span class="filter-icon" v-if="selectedFilters.includes(category)">✓</span>
                            </button>
                        </div>
                    </div>

                    <!-- Selected Filters Counter -->
                    <div class="selected-filters" v-if="hasSelectedFilters">
                        <p class="filter-count">
                            {{ selectedFilters.length }} filter{{ selectedFilters.length > 1 ? 's' : '' }} selected
                        </p>
                    </div>
                </div>

                <!-- Updated listings grid -->
                <div class="d-flex d-sm-block justify-content-center  row row-cols-1">
                    <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 g-4">
                        <div v-for="listing in filteredListings" :key="listing.uid">
                            <div class="card m-2" style="width: 100%;" @click="openPreview(listing)">
                                <img :src="listing.imageUrl" class="card-img-top">
                                <div class="card-body">
                                    <h5 class="card-title">{{ listing.title }}</h5>
                                    <p class="card-text description-text">{{ listing.description }}</p>
                                    <p class="card-text info-text"><strong>Location:</strong> {{ listing.location }}</p>
                                    <p class="card-text info-text"><strong>Skills: </strong> {{
                                        Array.isArray(listing.skills) ? listing.skills.join(', ') : listing.skills ||
                                        "No skills listed" }}</p>
                                    <p v-if="listing.isRecurring" class="card-text"><strong>Weekly:</strong> {{
                                        Array.isArray(listing.recurringDays) ? listing.recurringDays.join(', ') :
                                        listing.recurringDays || "No days listed" }}</p>
                                    <p v-else class="card-text"><strong>Date: </strong>{{listing.date}}</p>
                                </div>
                                <div class="card-footer text-center">
                                    <a :href="listing.mainurl" target="_blank" class="btn btn-primary" @click.stop>
                                        View Website
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <script>

            //scrolling

            document.addEventListener("DOMContentLoaded", function () {
                const scrollWrapper = document.querySelector('.scrollable-row-wrapper');

                let isDown = false;
                let startX;
                let scrollLeft;

                scrollWrapper.addEventListener('mousedown', (e) => {
                    isDown = true;
                    scrollWrapper.classList.add('active');
                    startX = e.pageX - scrollWrapper.offsetLeft;
                    scrollLeft = scrollWrapper.scrollLeft;
                });

                scrollWrapper.addEventListener('mouseleave', () => {
                    isDown = false;
                    scrollWrapper.classList.remove('active');
                });

                scrollWrapper.addEventListener('mouseup', () => {
                    isDown = false;
                    scrollWrapper.classList.remove('active');
                });

                scrollWrapper.addEventListener('mousemove', (e) => {
                    if (!isDown) return;
                    e.preventDefault();
                    const x = e.pageX - scrollWrapper.offsetLeft;
                    const walk = (x - startX) * 2; // The multiplier controls scroll speed
                    scrollWrapper.scrollLeft = scrollLeft - walk;
                });
            });

            //end scroll


            const app = Vue.createApp({
                data() {
                    return {
                        showMatchBar: false,
                        recommendedCards: [],
                        showPreview: false,
                        selectedCard: null,
                        selectedFilters: [], // Combined filters array
                        availableSkills: [],
                        availableCategories: [],
                        isLoading: false,  // Add this new data property
                        map: null,
                        marker: null,
                        isAdmin:false,

                    };
                },
                methods: {

                    showToast(message, success = true) {
                        const toastEl = document.getElementById('calendarToast');
                        const messageEl = document.getElementById('toastMessage');
                        messageEl.textContent = message;
                        messageEl.className = 'toast-body ' + (success ? 'bg-success' : 'bg-danger') + ' text-white';
                        const toast = new bootstrap.Toast(toastEl);
                        toast.show();
                    },

                    async send_to_calendar_recurring(recurringDays, startTime, endTime, recurring, title, startdate, enddate) {
                        try {
                            const docRef = await db.collection("UserEvents").add({
                                'Start Time': startTime,
                                'End Time': endTime,
                                'Days Needed': recurringDays,
                                'UID': userId,
                                'Recurring': recurring,
                                'Event Name': title,
                                'Start Date': startdate,
                                'End Date': enddate
                            });
                            this.showToast('Event successfully added to your calendar!', true);
                            console.log("Document ready");
                        } catch (e) {
                            this.showToast('Error adding event to calendar. Please try again.', false);
                            console.error("Error adding document: ", e);
                        }
                    },

                    async send_to_calendar_nonrecurring(daysOfWeek, startTime, endTime, recurring, title, date) {
                            try {
                                const docRef = await db.collection("UserEvents").add({
                                    'Start Time': startTime,
                                    'End Time': endTime,
                                    'Days Needed': daysOfWeek,
                                    'UID': userId,
                                    'Recurring': recurring,
                                    'Event Name': title,
                                    'Start Date': date,
                                    'End Date': date
                                });
                                this.showToast('Event successfully added to your calendar!', true);
                                console.log("Document ready");
                            } catch (e) {
                                this.showToast('Error adding event to calendar. Please try again.', false);
                                console.error("Error adding document: ", e);
                            }
                        },

                    clearAllFilters() {
                        this.selectedFilters = [];
                    },

                    toggleFilter(filter) {
                        const index = this.selectedFilters.indexOf(filter);
                        if (index > -1) {
                            this.selectedFilters.splice(index, 1);
                        } else {
                            this.selectedFilters.push(filter);
                        }
                    },

                    // Combined matching for both skills and categories
                    matchesFilters(listing) {
                        if (!this.selectedFilters.length) return true;

                        // Combine listing's skills and categories for matching
                        const listingTags = [
                            ...(Array.isArray(listing.skills) ? listing.skills : [listing.skills]),
                            ...(Array.isArray(listing.category) ? listing.category : [listing.category])
                        ]
                            .filter(tag => tag && tag !== 'None')
                            .map(tag => tag.toLowerCase());

                        // Check if ALL selected filters match at least one of the listing's tags
                        const selectedFiltersLower = this.selectedFilters.map(filter => filter.toLowerCase());
                        return selectedFiltersLower.every(filter => listingTags.includes(filter));
                    },


                    isValidListing(listing) {
                        return this.isValidDate(listing) && this.matchesFilters(listing);
                    },

                    isValidDate(listing) {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);

                        if (listing.isRecurring) {
                            if (!listing.recurringEndDate) return true;
                            const endDate = new Date(listing.recurringEndDate);
                            return endDate >= today;
                        } else {
                            if (!listing.date) return true;
                            const eventDate = new Date(listing.date);
                            return eventDate >= today;
                        }
                    },

                    async fetchListings() {
                        const db = firebase.firestore();
                        try {
                            const querySnapshot = await db.collection('listings').get();
                            const info = [];
                            const skillSet = new Set();
                            const categorySet = new Set();

                            querySnapshot.forEach((doc) => {
                                const data = doc.data();
                                const skills = Array.isArray(data.skills) ?
                                    data.skills.filter(skill => skill && skill !== 'None') :
                                    (data.skills ? [data.skills] : []);

                                const categories = Array.isArray(data.category) ?
                                    data.category.filter(cat => cat && cat !== 'None') :
                                    (data.category ? [data.category] : []);

                                // Collect all valid skills and categories
                                skills.forEach(skill => {
                                    if (skill && skill !== 'None') {
                                        skillSet.add(skill.trim());
                                    }
                                });

                                categories.forEach(category => {
                                    if (category && category !== 'None') {
                                        categorySet.add(category.trim());
                                    }
                                });

                                info.push({
                                    title: data.title || 'No title',
                                    description: data.description || 'No description',
                                    imageUrl: data.imageUrl || 'noimage.jpg',
                                    location: data.location || 'No location',
                                    skills: skills,
                                    category: categories,
                                    daysOfWeek: data.daysOfWeek || ['None'],
                                    mainurl: data.mainurl,
                                    email: data.email || ['None'],
                                    isRecurring: data.isRecurring,
                                    recurringDays: data.recurringDays,
                                    date: data.date,
                                    startTime: data.startTime,
                                    endTime: data.endTime,
                                    recurringStartDate: data.recurringStartDate,
                                    recurringEndDate: data.recurringEndDate,
                                    id:data.id
                                });
                            });

                            this.recommendedCards = info;
                            this.availableSkills = Array.from(skillSet).sort();
                            this.availableCategories = Array.from(categorySet).sort();
                            this.fetchUserData();
                        } catch (error) {
                            console.error('Error fetching listings:', error);
                        }
                    },
                    // Fetch user data based on authentication state
                    async fetchUserData() {
                        const db = firebase.firestore();  // Access Firestore using the compat syntax

                        firebase.auth().onAuthStateChanged(async (user) => {
                            if (user) {
                                const uid = user.uid;  // Get the logged-in user's UID
                                console.log("User ID:", uid);
                                if(uid=="Sx2Al5DFAEOazuO4ZO37dCOKQTt1"){
                                    this.isAdmin=true;
                                }
                                try {
                                    const querySnapshot = await db.collection('UserQuestionnaire')
                                        .where('uid', '==', uid).get();

                                    if (!querySnapshot.empty) {
                                        querySnapshot.forEach((doc) => {
                                            const data = doc.data();  // Get the document data
                                            console.log("User data found:", data);

                                            // Store the user's data in a local variable
                                            const userQuestionnaireData = {
                                                uid: data.uid,  // Store the user's UID
                                                interests: data.interests || [],  // Array of interests
                                                skills: data.skills || [],  // Array of skills
                                                location: data.location || 'No location',  // Location (e.g., postal code)
                                                availability: data.availability || []  // User's available days
                                            };

                                            // Show match bar and calculate the match score using listings and user data
                                            this.showMatchBar = true;
                                            this.calculateMatch(userQuestionnaireData);

                                        });
                                    } else {
                                        console.log("No document found in userQuestionnaire for UID:", uid);

                                    }

                                } catch (error) {
                                    console.error("Error fetching user data:", error);
                                }

                            } else {
                                console.log("No user is logged in.");
                                this.showMatchBar = false;  // Hide match bar if no user is logged in
                            }
                        });
                    },

                    // Calculate the match score for each listing
                    async calculateMatch(userData) {
                        if (userData && this.recommendedCards.length) {
                            this.showMatchBar = true;
                            this.isLoading = true;  // Start loading

                            try {
                                const matchScorePromises = this.recommendedCards.map(async (listing) => {
                                    const matchScore = await this.calculateMatchScore(userData, listing);
                                    return {
                                        ...listing,
                                        matchScore
                                    };
                                });

                                // Wait for all match score calculations to complete
                                this.recommendedCards = await Promise.all(matchScorePromises);

                                // Sort listings based on matchScore descending once
                                this.recommendedCards.sort((a, b) => b.matchScore - a.matchScore);

                            } catch (error) {
                                console.error("Error calculating matches:", error);
                            } finally {
                                this.isLoading = false;  // End loading regardless of success/failure
                            }
                        } else {
                            this.showMatchBar = false;
                            this.isLoading = false;
                        }
                    },

                    // Calculate the match score based on user and listing data
                    async calculateMatchScore(user, listing) {
                        // Weights for each criterion
                        const weights = {
                            interests: 0.3,
                            skills: 0.3,
                            location: 0.2,
                            availability: 0.2
                        };

                        // Interest match calculation
                        const interestMatch = user.interests.some(interest => listing.category.includes(interest)) ? 100 : 0;

                        // Skills match calculation
                        const matchedSkills = listing.skills.filter(skill => user.skills.includes(skill)).length;
                        const skillsMatch = (matchedSkills / listing.skills.length) * 100;

                        // Location match (for now assume 100%)
                        // var locationMatch = 100;
                        // Brandyn Testing stuff
                        const originLocation = encodeURIComponent(user.location);
                        const destinationLocation = encodeURIComponent(listing.location);
                        if (listing.location !== "No location") {
                            const response = await axios.get("http://brandynchua.pythonanywhere.com/google_api/distancegetter", {
                                params: {
                                    origins: user.location,
                                    destinations: listing.location,
                                    units: 'metric',
                                }
                            })
                                .then(response => {
                                    var temp_holding = response.data
                                    var distance_value = temp_holding.rows[0].elements[0].distance.value
                                    // Distance calculation
                                    // If distance is more then 20km, set to 0. Else, 20km minus 
                                    if (distance_value >= 20000) {
                                        locationMatch = 0
                                    }
                                    else {
                                        locationMatch = (20000 - distance_value) / 200
                                    }
                                })
                                .catch(error => {
                                    console.error("No distance? : ", error)
                                    console.log("error location: ", destinationLocation)
                                })
                        }

                        // Availability match calculation
                        // Log the value and type of listing.daysOfWeek for debugging
                        const matchedDays = listing.daysOfWeek.filter(day => user.availability.includes(day)).length;
                        const availabilityMatch = (matchedDays / listing.daysOfWeek.length) * 100;

                        // Total match score calculation
                        const totalMatchScore = Math.round(
                            (weights.interests * interestMatch) +
                            (weights.skills * skillsMatch) +
                            (weights.location * locationMatch) +
                            (weights.availability * availabilityMatch)
                        );

                        return totalMatchScore;
                    },
                    async initializeMap(postalCode) {
                        try {
                            console.log("Starting map initialization...");
                            
                            // Wait for DOM to be ready
                            await Vue.nextTick();
                            
                            // Get and verify container
                            const mapContainer = document.getElementById('previewMap');
                            if (!mapContainer) {
                                throw new Error('Map container not found');
                            }

                            // Force container dimensions
                            mapContainer.style.height = '300px';
                            mapContainer.style.minHeight = '300px';
                            mapContainer.style.width = '100%';
                            mapContainer.style.position = 'relative';
                            mapContainer.style.display = 'block';

                            // Log container dimensions
                            console.log("Container dimensions:", {
                                offsetHeight: mapContainer.offsetHeight,
                                offsetWidth: mapContainer.offsetWidth,
                                clientHeight: mapContainer.clientHeight,
                                clientWidth: mapContainer.clientWidth
                            });

                            // Clean up existing map
                            if (this.map) {
                                this.map.remove();
                                this.map = null;
                            }

                            // Wait a brief moment for any animations to complete
                            await new Promise(resolve => setTimeout(resolve, 100));

                            // Initialize map
                            this.map = L.map('previewMap', {
                                center: [1.3521, 103.8198], // Singapore
                                zoom: 11,
                                zoomControl: true
                            });

                            // Add tile layer immediately
                            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                maxZoom: 19,
                                attribution: '© OpenStreetMap'
                            }).addTo(this.map);

                            // Force a resize immediately
                            this.map.invalidateSize();

                            // If we have a postal code, geocode and update map
                            if (postalCode) {
                                const geocoder = new google.maps.Geocoder();
                                
                                const results = await new Promise((resolve, reject) => {
                                    geocoder.geocode({
                                        address: `${postalCode}, Singapore`,
                                        region: 'sg'
                                    }, (results, status) => {
                                        if (status === 'OK' && results[0]) {
                                            resolve(results[0]);
                                        } else {
                                            reject(new Error(`Geocoding failed: ${status}`));
                                        }
                                    });
                                });

                                const lat = results.geometry.location.lat();
                                const lng = results.geometry.location.lng();
                                
                                // Update view and add marker
                                this.map.setView([lat, lng], 16);
                                
                                if (this.marker) {
                                    this.map.removeLayer(this.marker);
                                }
                                
                                this.marker = L.marker([lat, lng])
                                    .addTo(this.map)
                                    .bindPopup(this.selectedCard.title)
                                    .openPopup();
                            }

                            // Force another resize after a delay to handle any remaining animation
                            setTimeout(() => {
                                this.map.invalidateSize();
                            }, 250);

                        } catch (error) {
                            console.error("Map initialization error:", error);
                            const mapContainer = document.getElementById('previewMap');
                            if (mapContainer) {
                                mapContainer.innerHTML = `
                                    <div class="alert alert-warning" style="margin: 10px;">
                                        Unable to load map: ${error.message}
                                    </div>
                                `;
                            }
                        }
                    },
                async openPreview(card) {
                    try {
                        const currentFilters = [...this.selectedFilters];
                        this.selectedCard = card;
                        this.showPreview = true;
                        this.selectedFilters = currentFilters;
                        document.body.classList.add('modal-open');

                        // Wait for the DOM to update before initializing the map
                        await Vue.nextTick();
                        
                        if (card.location && card.location !== 'No location') {
                            await this.initializeMap(card.location);
                        }
                    } catch (error) {
                        console.error("Error in openPreview:", error);
                    }
                },

                closePreview() {
                    const currentFilters = [...this.selectedFilters];
                    this.showPreview = false;
                    this.selectedCard = null;
                    this.selectedFilters = currentFilters;
                    document.body.classList.remove('modal-open');

                    // Properly clean up the map
                    if (this.map) {
                        this.map.remove();
                        this.map = null;
                    }
                    if (this.marker) {
                        this.marker = null;
                    }
                }
                },
                computed: {
                    // Helper computed property for selected filters visibility
                    hasSelectedFilters() {
                        return this.selectedFilters.length > 0;
                    },

                    // Get currently selected skills
                    selectedSkills() {
                        return this.selectedFilters.filter(filter =>
                            this.availableSkills.includes(filter)
                        );
                    },

                    // Get currently selected categories
                    selectedCategories() {
                        return this.selectedFilters.filter(filter =>
                            this.availableCategories.includes(filter)
                        );
                    },

                    validListings() {
                        return this.recommendedCards.filter(listing => this.isValidListing(listing));
                    },

                    topRecommendedCards() {
                        return this.recommendedCards
                            .filter(listing => this.isValidDate(listing))
                            .slice(0, 8);
                    },

                    filteredListings() {
                        if (this.showMatchBar) {
                            const remainingListings = this.recommendedCards
                                .filter(listing => this.isValidDate(listing))
                                .slice(8);

                            if (!this.selectedFilters.length) {
                                return remainingListings;
                            }

                            return remainingListings.filter(listing => this.matchesFilters(listing));

                        }
                        else{
                            const remainingListings = this.recommendedCards.filter(listing=> this.isValidDate(listing))
                            return remainingListings.filter(listing => this.matchesFilters(listing));
                        }
                    }
                },
                created() {
                    this.fetchListings();
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && this.showPreview) {
                            this.closePreview();
                        }
                    });
                }
            });

            vm = app.mount('#app');
        </script>